package main

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"github.com/MasterWigu/Thesis/appServer/APIs"
	"github.com/gin-gonic/gin"
	"log"
	"net/http"

	"github.com/swaggo/files"                            // swagger embed files
	"github.com/swaggo/gin-swagger"                      // gin-swagger middleware
	_ "github.com/swaggo/gin-swagger/example/basic/docs" // docs is generated by Swag CLI, you have to import it.
)

// @title Fabric Module API
// @version 1.0
// @description This is a sample server fasda server.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host fabric-module1:8090
// @BasePath /



func declareAPIEndpoint() *gin.Engine {
	r := gin.Default()

	/*config := cors.DefaultConfig()

	config.AllowOrigins = []string{"https://webserver-module1:8070"}
	config.AllowMethods = []string{"GET", "POST", "OPTIONS"}
	config.AllowHeaders = []string{"access-control-allow-origin, access-control-allow-headers"}
	config.ExposeHeaders = []string{"Content-Length"}
	r.Use(cors.New(config))*/

	url := ginSwagger.URL("https://localhost:8090/docs/doc.json") // The url pointing to API definition
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler, url))


	r.GET("/docs/doc.json", func(context *gin.Context) {
		context.File("goapp/docs/swagger.json")
	})

	r.POST("/loginUser", loginHandler)

	r.GET("/assets/types", getAssetTypesHandler)
	r.POST("/assets/types", addAssetTypeHandler)

	r.GET("/assets/:type", getAssetsByTypeHandler)
	r.GET("/asset/:id", getAssetHandler)
	r.POST("/asset", registerAssetHandler)
	r.POST("/asset/plan", registerAssetPlanHandler)
	r.POST("/asset/modify", modifyAssetHandler)
	r.POST("/asset/modify/plan", modifyAssetPlanHandler)
	r.PUT("/asset/:id/confirm", confirmAssetHandler)
	r.DELETE("/asset/:assetId", removeAssetHandler)
	r.GET("/asset/:id/dependencies", listDependenciesHandler)
	r.GET("/asset/:id/dependants", listDependantsHandler)
	r.POST("/asset/:assetId/dependencies/:dependencyId", addDependencyHandler)
	r.DELETE("/asset/:assetId/dependencies/:depId", removeDependencyHandler)

	r.GET("/appliedTool/:id", getAppliedToolHandler)
	r.POST("/appliedTool", createAppliedToolHandler)
	r.POST("/appliedTool/plan", createAppliedToolPlanHandler)
	r.POST("/appliedTool/finish", finishAppliedToolHandler)
	r.POST("/appliedTool/revert", revertAppliedToolHandler)

	return r
}

func startListening(r *gin.Engine) {
	err := r.RunTLS(":8090", "/certs/cert.pem", "/certs/key.pem")
	if err != nil {
		log.Fatalf("could not start listening server: %v", err)
	}
}

func sessionManager(c *gin.Context, changeContext bool) (*User, error) {
	sessionId, err := c.Cookie("SESSION_ID")
	if err != nil {
		if changeContext {
			c.String(http.StatusUnauthorized, "Session id not found, please login")
		}
		return nil, err
	}

	user, notFound := checkLoggedIn(sessionId)
	if notFound {
		if changeContext {
			c.String(http.StatusUnauthorized, "Invalid session id, please (re)login")
			c.SetCookie("SESSION_ID", sessionId, -1, "/", "fabric-module", true, true) //Ask to delete cookie (max age = -1)
		}
		return nil, fmt.Errorf("invalid session id")
	}

	if changeContext {
		c.SetCookie("SESSION_ID", user.sessionId, 86400, "/", "fabric-module", true, true)
	}

	return user, nil
}


// loginHandler godoc
// @Summary Login a new user and receive a session ID
// @Description Makes the login of the user, generates a session and returns a session ID via a cookie and on the body of the response.
// @Tags root
// @Accept */*
// @Produce json
// @Success 200 {object} APIs.LoginResp
// @Router /loginUser [get]
func loginHandler(c *gin.Context) {
	// receives a zip with the user's credentials
	// stores the user in the logged in users list
	// creates cookie for the user
	// sends zip and cookie to the ledger module for effective verification
	// sends login status to user (and cookie)

	//user, err := sessionManager(c, false)
	//if err == nil { //If user ir already logged in
	//	c.String(http.StatusOK, fmt.Sprintf("Logged in!"))
	//	return
	//}

	formFile, err := c.FormFile("identityFile")
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	file, err := formFile.Open()
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	// Generate 40 byte session id
	b := make([]byte, 40)
	_, err = rand.Read(b)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}
	sessId := base64.URLEncoding.EncodeToString(b)

	user, err := loginUser(file, formFile.Size, sessId)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusUnauthorized)
		return
	}
	if user == nil {
		c.Status(http.StatusUnauthorized)
		return
	}

	c.SetCookie("SESSION_ID", sessId, 86400, "/", "fabric-module1", true, true)

	respJson := APIs.LoginResp{Perms: user.userPerm, LedgerSessId: sessId, Username: user.username}

	c.JSONP(http.StatusOK, respJson)
}


// getAssetTypesHandler godoc
// @Summary Gets the existing asset types
// @Description Makes a request to the ledger to get the existing asset types. Needs session id set as cookie
// @Tags root
// @Security ApiKeyAuth
// @Accept */*
// @Produce json
// @Success 200 {object} APIs.AssetTypesResp
// @Router /assets/types [get]
func getAssetTypesHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	responseStruct, err := processor.GetAssetTypes(user)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.JSONP(http.StatusOK, responseStruct)
}

// addAssetTypeHandler godoc
// @Summary Adds a new asset type to the ledger
// @Description Makes a request to the ledger to add a new asset type. Needs session id set as cookie
// @Tags AssetTypes
// @Security ApiKeyAuth
// @Accept */*
// @Produce json
// @Success 200 {object} APIs.AssetTypesResp
// @Router /assets/types [post]
func addAssetTypeHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	if user.userPerm != "admin" {
		c.Status(http.StatusUnauthorized)
		return
	}

	newType := c.Query("newType")
	//newType := c.GetString("newType")
	if newType == "" {
		c.Status(http.StatusBadRequest)
		return
	}

	responseStruct, err := processor.AddAssetType(user, newType)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.JSONP(http.StatusOK, responseStruct)
}

func getAssetsByTypeHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}


	assetType := c.Param("type")
	//newType := c.GetString("newType")
	if assetType == "" {
		c.Status(http.StatusBadRequest)
		return
	}

	responseStruct, err := processor.GetAssetsByType(user, assetType)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.JSONP(http.StatusOK, responseStruct)
}

func getAssetHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	assetId := c.Param("id")
	if assetId == "" {
		c.Status(http.StatusBadRequest)
		return
	}

	responseStruct, err := processor.GetAssetById(user, assetId)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.JSONP(http.StatusOK, responseStruct)
}

func registerAssetHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	var newAsset APIs.AssetResp

	err = c.BindJSON(&newAsset)
	if err != nil {
		c.Status(http.StatusBadRequest)
		return
	}

	responseStruct, err := processor.RegisterAsset(user, &newAsset)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.JSONP(http.StatusOK, responseStruct)
}

func registerAssetPlanHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	var newAsset APIs.AssetResp

	err = c.BindJSON(&newAsset)
	if err != nil {
		c.Status(http.StatusBadRequest)
		return
	}

	responseStruct, err := processor.RegisterAssetPlan(user, &newAsset)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.JSONP(http.StatusOK, responseStruct)
}

func modifyAssetHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	var newAsset APIs.AssetResp

	err = c.BindJSON(&newAsset)
	if err != nil {
		c.Status(http.StatusBadRequest)
		return
	}

	responseStruct, err := processor.ModifyAsset(user, &newAsset)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.JSONP(http.StatusOK, responseStruct)
}

func modifyAssetPlanHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	var newAsset APIs.AssetResp

	err = c.BindJSON(&newAsset)
	if err != nil {
		c.Status(http.StatusBadRequest)
		return
	}

	responseStruct, err := processor.ModifyAssetPlan(user, &newAsset)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.JSONP(http.StatusOK, responseStruct)
}

func confirmAssetHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	assetId := c.Param("id")
	if assetId == "" {
		c.Status(http.StatusBadRequest)
		return
	}

	responseStruct, err := processor.ConfirmAsset(user, assetId)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.JSONP(http.StatusOK, responseStruct)
}

func removeAssetHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	assetId := c.Param("assetId")
	if assetId == "" {
		c.Status(http.StatusBadRequest)
		return
	}

	err = processor.RemoveAsset(user, assetId)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.Status(http.StatusOK)
}


func listDependenciesHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	assetId := c.Param("id")
	if assetId == "" {
		c.Status(http.StatusBadRequest)
		return
	}

	responseStruct, err := processor.ListDependencies(user, assetId)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.JSONP(http.StatusOK, responseStruct)
}

func listDependantsHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	assetId := c.Param("id")
	if assetId == "" {
		c.Status(http.StatusBadRequest)
		return
	}

	responseStruct, err := processor.ListDependants(user, assetId)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.JSONP(http.StatusOK, responseStruct)
}

func addDependencyHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	assetId := c.Param("assetId")
	if assetId == "" {
		c.Status(http.StatusBadRequest)
		return
	}

	depId := c.Param("dependencyId")
	if depId == "" {
		c.Status(http.StatusBadRequest)
		return
	}

	originId := c.Query("originId")
	// origin id can be empty

	err = processor.AddDependency(user, assetId, depId, originId)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.Status(http.StatusOK)
}

func removeDependencyHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	assetId := c.Param("assetId")
	if assetId == "" {
		c.Status(http.StatusBadRequest)
		return
	}

	depId := c.Param("depId")
	if depId == "" {
		c.Status(http.StatusBadRequest)
		return
	}

	err = processor.RemoveDependency(user, assetId, depId)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.Status(http.StatusOK)
}


func createAppliedToolHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	var appliedTool APIs.AppliedToolResp

	err = c.BindJSON(&appliedTool)
	if err != nil {
		c.Status(http.StatusBadRequest)
		return
	}

	responseStruct, err := processor.CreateAppliedTool(user, &appliedTool)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.JSONP(http.StatusOK, responseStruct)
}

func createAppliedToolPlanHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	var appliedTool APIs.AppliedToolResp

	err = c.BindJSON(&appliedTool)
	if err != nil {
		c.Status(http.StatusBadRequest)
		return
	}

	responseStruct, err := processor.CreateAppliedToolPlan(user, &appliedTool)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.JSONP(http.StatusOK, responseStruct)
}

func finishAppliedToolHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	var appliedTool APIs.AppliedToolResp

	err = c.BindJSON(&appliedTool)
	if err != nil {
		c.Status(http.StatusBadRequest)
		return
	}

	if appliedTool.AppliedTool.AppliedTo == nil || len(appliedTool.AppliedTool.AppliedTo) == 0 {
		c.Status(http.StatusBadRequest)
		return
	}

		responseStruct, err := processor.FinishAppliedTool(user, &appliedTool, appliedTool.AppliedTool.AppliedTo)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.JSONP(http.StatusOK, responseStruct)
}

func revertAppliedToolHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	var appliedTool APIs.AppliedToolResp

	err = c.BindJSON(&appliedTool)
	if err != nil {
		c.Status(http.StatusBadRequest)
		return
	}

	responseStruct, err := processor.RevertAppliedTool(user, &appliedTool)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.JSONP(http.StatusOK, responseStruct)
}

func getAppliedToolHandler(c *gin.Context) {
	user, err := sessionManager(c, true)
	if err != nil {
		log.Println(err)
		return
	}

	appliedToolId := c.Param("id")
	if appliedToolId == "" {
		c.Status(http.StatusBadRequest)
		return
	}

	responseStruct, err := processor.GetAppliedTool(user, appliedToolId)
	if err != nil {
		log.Println(err)
		c.Status(http.StatusInternalServerError)
		return
	}

	c.JSONP(http.StatusOK, responseStruct)
}


